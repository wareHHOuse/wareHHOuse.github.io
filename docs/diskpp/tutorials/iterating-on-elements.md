---
title: Iterating on elements
parent: Getting started with DiSk++
nav_order: 2
compress_html: false
---

# Tutorial 1: creating a mesh and iterating on its elements

DiSk++ can read and use various kinds of mesh. It can also generate simple meshes on the unit square/cube: the automatic mesh generators can be handy for convergence tests.

This tutorial will guide you in creating a mesh and iterating on its elements.

{: .highlight}
Code for this example: `apps/diskpp_tutorials/diskpp_tutorial_1.cpp`

## Automatic meshing of the unit square/cube

As described in [here]({% link docs/diskpp/getting-started.md %}), each mesh in DiSk++ uses a specific storage class. In this first tutorial we will consider

 * Simplicial 2D meshes, handled with objects of type `disk::simplicial_mesh<T,2>`
 * Simplicial 3D meshes, handled with objects of type `disk::simplicial_mesh<T,3>`
 * Polygonal 2D meshes, handled with objects of type `disk::generic_mesh<T,2>`

We will use the DiSk++ internal mesh generators to obtain a mesh for the unit square or cube.

Go now to the `main()` of `apps/diskpp_tutorials/diskpp_tutorial_1.cpp`: after the command line parsing code, you will find the actual calls to the mesh generators.

### Creating a simplicial mesh
```cpp
using mesh_type = disk::simplicial_mesh<T,2>;
mesh_type msh;
auto mesher = disk::make_simple_mesher(msh);
for (auto nr = 0; nr < num_refs; nr++)
    mesher.refine();
```

The first line defines `mesh_type` as a type alias for `disk::simplicial_mesh<T,2>`, then in the second line we instantiate the actual mesh object. Subsequently, in the third line we ask to DiSk++ to give us a mesher for `msh`. We have now a mesh of 4 triangles on the unit square. Finally, each call to `.refine()` halves the mesh step by dividing each element in 4 subtriangles. Exactly the same logic is applied for tetrahedral meshes of the unit cube: in the following code, notice how only the definition of `mesh_type` changes.

```cpp
using mesh_type = disk::simplicial_mesh<T,3>;
mesh_type msh;
auto mesher = disk::make_simple_mesher(msh);
for (auto nr = 0; nr < num_refs; nr++)
    mesher.refine();
```

### Creating a polygonal mesh
DiSk++ can cover the unit square with hexagonal tiles, giving you an hexagon-dominated mesh. Here is the code:
```cpp
using mesh_type = disk::generic_mesh<T,2>;
mesh_type msh;
auto mesher = disk::make_fvca5_hex_mesher(msh);
mesher.make_level(num_refs);
```
Compared to the simplicial case, we can notice some small differences:
 * `mesh_type` is `disk::generic_mesh<T,2>;`,
 * the mesher is obtained by calling `disk::make_fvca5_hex_mesher()`: here the name recalls the FVCA5 benchmark, but actually the pattern generated by this mesher was not part of the it. It is only a reference to [this code](https://github.com/wareHHOuse/fvca-meshes/blob/master/code/hexagonalmesh.m), which was clearly written by someone close to the FVCA5 people. Until now however the author remains unknown.
 * there is no `.refine()`, but `.make_level()`, which controls how many times the base pattern is replicated inside the unit square

## Doing something with the meshes
Let's now analyze the subsequent code, in particular the call `print_element_properties(msh)`. By looking at the actual definition of that function, we notice that it is actually a template:
```cpp
/* This function is generic and will work for any kind of mesh */
template<typename Mesh>
void
print_element_properties(const Mesh& msh)
{
    for (auto& cl : msh)
    {
        std::cout << cl << std::endl;
        std::cout << "  Diameter: " << diameter(msh, cl) << std::endl;
        std::cout << "  Measure: " << measure(msh, cl) << std::endl;
        std::cout << "  Barycenter: " << barycenter(msh, cl) << std::endl;
        auto fcs = faces(msh, cl);
        for (auto& fc : fcs)
        {
            std::cout << "  " <<fc << std::endl;
            std::cout << "    Diameter: " << diameter(msh, fc) << std::endl;
            std::cout << "    Measure: " << measure(msh, fc) << std::endl;
            std::cout << "    Barycenter: " << barycenter(msh, fc) << std::endl;
        }
    }
}
```
This function will be compiled in different ways according to the type of the parameter `msh`. Therefore, if we consider for example the call to `measure()`, if the mesh is a 2D one it will return the area of the specified element. Otherwise, if the mesh is 3D, `measure()` will return a volume. You can also see that the same functions can be used on both cells and faces: in each case you get what you expect, without caring about what your actual mesh element is. This is the way in which DiSk++ realizes the "write code once, run it on any mesh" principle.
